# Ответы на вопросы по тестированию

## 1. В чём основное различие между unittest и pytest?

`unittest` — это встроенный модуль Python, основанный на объектно-ориентированном подходе. Тесты пишутся в виде классов, наследующих `unittest.TestCase`, и каждый тест — это метод, начинающийся с `test_`.

`pytest` — это сторонний фреймворк, который позволяет писать тесты как обычные функции. Он предлагает более лаконичный синтаксис, мощную систему фикстур, поддержку параметризации и множество плагинов. Pytest также предоставляет более удобный и читаемый вывод ошибок.

## 2. Почему важно использовать автоматические тесты при разработке?

Автоматические тесты позволяют:

- Быстро находить ошибки на ранних этапах разработки.
- Убедиться, что изменения в коде не ломают существующий функционал.
- Документировать ожидаемое поведение системы.
- Повысить надёжность и стабильность проекта.
- Упростить процесс интеграции и доставки (CI/CD).
- Сэкономить время по сравнению с ручным тестированием.

## 3. Какие есть виды ассертов в unittest и pytest?

### В `unittest`:

- `assertEqual(a, b)` — проверка равенства.
- `assertNotEqual(a, b)` — проверка неравенства.
- `assertTrue(x)` / `assertFalse(x)` — проверка булевых значений.
- `assertIs(a, b)` / `assertIsNot(a, b)` — проверка идентичности объектов.
- `assertIsNone(x)` / `assertIsNotNone(x)` — проверка на None.
- `assertIn(a, b)` / `assertNotIn(a, b)` — проверка вхождения.
- `assertRaises(Exception, func, *args)` — проверка на исключение.

### В `pytest`:

Используются обычные Python-выражения с `assert`, например:

- `assert a == b`
- `assert x in y`
- `assert func() > 0`

Pytest автоматически перехватывает ошибки и выводит подробную информацию при падении теста.

## 4. Что делает @pytest.mark.parametrize?

`@pytest.mark.parametrize` позволяет запускать один и тот же тест с разными наборами входных данных. Это удобно для проверки функции на множестве кейсов без дублирования кода.

Пример:

```python
import pytest

@pytest.mark.parametrize("a, b, expected", [
    (1, 2, 3),
    (5, 5, 10),
    (0, 0, 0),
])
def test_add(a, b, expected):
    assert a + b == expected

## 5. В каких случаях предпочтительнее использовать pytest вместо unittest?

`pytest` предпочтительнее использовать, когда:

- Требуется писать большое количество тестов с разными входными данными.
- Необходима гибкая и мощная система фикстур.
- Важна краткость и читаемость тестов.
- Используются сторонние плагины (например, для покрытия кода, тестирования асинхронных функций и т.д.).
- Требуется удобный и подробный вывод ошибок при падении тестов.
- Проект развивается командой, и важно обеспечить простоту написания и поддержки тестов.

В целом, `pytest` считается более современным и удобным инструментом для большинства проектов.


